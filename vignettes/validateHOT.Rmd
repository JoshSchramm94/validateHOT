---
title: "validateHOT: Validate Your Holdout Task &#127919;"
author: "Joshua Schramm and Marcel Lichters"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{validateHOT: Validate Your Holdout Task &#127919;}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\\VignetteDepends{dplyr}
  %\\VignetteDepends{magrittr}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<code>validateHOT</code> is a package to validate your validation/ holdout task and test whether your model is valid in terms of predicting outside choice sets.

We created <code>validateHOT</code> to support students our practitioners who are less familiar with *R*. Moreover, we would also like to provide an easy and convenient way to validate a validation/ holdout task for all the [Sawtooth Software](https://sawtoothsoftware.com/) users, who would like to validate their validation/ holdout task in *R* for open-science purposes.

In this vignette we would like to present to you ...

-   ... how to create utility scores for a validation/ holdout task of a *CBC*, *ACBC*, or *MaxDiff* based on the **raw utilities** of a *Hierarchical* *Bayes* estimation which was run in *Sawtooth Software*
-   ... measure validation metrics which are often reported for a validation/ holdout task in research papers
    -   Hit rate (<code>hitrate</code>)
    -   Kullback-Leibler-Divergence (<code>kl</code>)
    -   Mean absolute error (<code>mae</code>)
    -   Mean hit probability (<code>mhp</code>)
    -   Median absolute error (<code>medae</code>)
    -   Root-mean-squared error (<code>rmse</code>)
-   ... measure metrics of the confusion matrix
    -   <code>accuracy</code>
    -   F1-score (<code>f1</code>)
    -   <code>precision</code>
    -   <code>recall</code>
    -   <code>specificity</code>
-   ... and how to use <code>validateHOT</code> for simulation purposes
    -   Frequency of how many products are bought on average of a specified assortment (<code>freqassort</code>)
    -   How many participants are reached with a specified assortment (buying at least one alternative of the assortment; <code>reach</code>)
    -   calculating the share of preference of specified set (<code>shareofpref</code>)

## Installation

You can install `validateHOT` by using the `devtools` package (Wickham et al., 2022).

```{r}
# install.packages("devtools")
# devtools::install_github("JoshSchramm94/validateHOT")
```

Afterwards, we will load the package.

```{r setup}
library(validateHOT)
```

## `createHOT`: creating validation/ holdout task in *R*

At first, we have to create the validation/ holdout task, which means that we need to create the utilities for each alternative. This is quite easy for a *MaxDiff* (also known as Best-Worst Scaling case 1 or object-case), however, for a *CBC* or *ACBC*, we need to add the utilities of each attribute level and might even have to interpolate some values, if they are coded as *linear* or *piecewise*.

### MaxDiff

We use the data set `MaxDiff` that comes with the package and store the utilities in the data set `HOT`. In this example, we assume that we have a validation task with 7 alternatives (`prod = 7`) plus a no-buy option (`None = 19`), so a total of 8 alternatives a participant can choose from in a validation/ holdout task in a *MaxDiff* study (`method = "MaxDiff"`). Furthermore, we specify the column index of both the `id` (unique identifier) and `choice` (the actual choice in the validation/ holdout task). To specify the 7 alternatives in the validation/ holdout task, we use `prod.levels` and specify their column indexes in a *list*. In case we wanted to keep further variables from our original data set, we could use the argument `varskeep` and specify their column index.

**Please you need to specify the column index and not the column names for `validateHOT`!**

```{r, eval = F}
HOT <- createHOT(
  data = MaxDiff,
  id = 1,
  None = 19,
  prod = 7,
  prod.levels = list(3, 10, 11, 15, 16, 17, 18),
  method = "MaxDiff",
  choice = 20
)
```

> In case you have a forced-choice validation/ holdout task, just do not specify the `None` argument.

### Choice-Based Conjoint

#### Part-Worth utilities only

In case, you conduct a *CBC* (`method = "CBC"`) and all attributes are coded as part-worth, the following example will help you to create the total utilities for your alternatives. We use the `CBC` data set, which comes with `validateHOT`. This example shows a *CBC* with 3 alternatives (`prod = 3`) plus the alternative not to choose any of those, whose utility is stored in column index 21 (`None = 21`). We again specify the column index of `id` and the actual choice, `choice`, in the validation/ holdout task.

When using *CBC* or *ACBC*, we need to specify the coding, where *0* stands for part-worth coding, *1* for linear coding, and *2* for piecewise coding. Since we only have part-worth coding we set `coding = c(0, 0, 0)`.

Finally, we specify the attribute levels for each alternative. For example, the first alternative is composed of the following column indexes `c(4, 9, 19)`, namely, `r colnames(CBC)[4]`, `r colnames(CBC)[9]`, and `r colnames(CBC)[19]`. The second is composed of the column indexes `c(8, 12, 17)`, namely, `r colnames(CBC)[8]`, `r colnames(CBC)[12]`, and `r colnames(CBC)[17]`; etc.

```{r, eval = F}
createHOT(
  data = CBC,
  id = 1,
  None = 21,
  prod = 3,
  prod.levels = list(c(4, 9, 19), c(8, 12, 17), c(5, 10, 17)),
  coding = c(0, 0, 0),
  method = "CBC",
  choice = 22
)
```

#### Linear-coded attribute

Now, let us imagine that instead of having all variables coded as part-worth, you also include 1 (or more) variables that are linear-coded. So, let us run again a *CBC* (`method = "CBC"`). All settings are the same as shown in the example above, however, this time we changed the coding to `coding = c(0, 0, 1)`, which tells us that the first two attributes are part-worth coded and the last variable is linear-coded. How will this impact the way we define our products? We can see that when we specify the third attribute for our three alternatives, we write down a value that this alternative should have for attribute 3. In this example, let us assume that the third attribute is weight. The first alternative in our validation/ holdout task is assumed to have a weight of 60 (`c(4, 9, 60)`), the second a weight of `40`, and the last alternative a weight of `45`.

In order to interpolate these values from our attribute levels, we next have to define the values we used for the levels in the HB settings. Please be aware that in the case of Sawtooth Software they recommend to recode the values of linear attributes for converging purposes (see, e.g., Orme & Chrzan, 2017, p. 108).

In order to let `validateHOT` interpolate the values for your validation/ holdout task, please make sure to insert the exact values you also specify for your *hierarchical Bayes* estimation in Sawtooth. You specify these values in `interpolate.levels` as a list. In the example of `CBC_lin`, there are 7 levels ranging from 10 to 70. Please make sure to include **all** levels of the linear-coded attribute. Next we have to specify the column index of the linear-coded attribute by specifying `lin.p`. Sawtooth Software just provides you one coefficient for your linear-coded values, therefore, we only have one column index.

Finally, in our example, we would also like to keep some variables that should be attached to the data frame we are creating. We can specify the column index(es) of the variables we would like to keep in `varskeep`.

> [**Important**]{.underline}: The value you would like to interpolate (in the example below 60, 40, and 45) need to be within the range you specify in `Ã¬nterpolate.levels`. For example, instead of using `c(10, 20, 30, 40, 50, 60, 70)`, we could also use `c(1, 2, 3, 4, 5, 6, 7)` or even better if we zero-center it to `c(-3, -2, -1, 0, 1, 2, 3)`. In this case we would need to adapt the values to be interpolate as well, so in our case 60 becomes 2, 40 becomes 0, and 45 becomes 0.5.

```{r}
HOT <- createHOT(
  data = CBC_lin,
  id = 1,
  None = 15,
  prod = 3,
  prod.levels = list(c(4, 9, 60), c(8, 12, 40), c(5, 10, 45)),
  interpolate.levels = list(c(10, 20, 30, 40, 50, 60, 70)),
  lin.p = 14,
  coding = c(0, 0, 1),
  method = "CBC",
  varskeep = 17,
  choice = 16
)
```

### Adaptive Choice-Based Conjoint (ACBC)

Finally, let us introduce you how to use `validateHOT` for an adaptive choice-based conjoint (ACBC). We also provide two examples, which are typical issues you might face.

#### Linear-coded ACBC price

In the first example, we would like to introduce you the example if you are using a linear-coded price for your ACBC. This price is not coded with 1 in `coding`, however, since it is a little bit different than normal linear-coded variables (e.g., you get 2 coefficients instead of just one), we approach this a little bit different.

For our example, we will use the `ACBC` data set, which is also provided by `validateHOT`. If you take a look at the data frame, you see that there are a total of 8 attributes, plus 2 price coefficients (`Price_2.093` as well as `Price_27.287`), and the `none` coefficient. Since all 8 attributes are part-worth coded, the setup is the same as for the CBC.

For our example, we use a validation/ holdout task with 6 alternatives plus a no-buy alternative. First, we define the 6 alternatives. We can see that for `prod1`, we again indicate the column index for the eight different attributes. Finally, the price (last element of the vector, e.g., for `prod1` this is `15.99`) is linear-coded.

After defining each alternative in the validation/ holdout task, let us look at the `createHOT` function. We specify our `data`, the column index of `id`, the column index of the no-buy alternative (`None`), the number of alternatives in the validation/ holdout task (`prod = 6`), the products, which we have defined before, the method (`ACBC`), and the column index of the actual choice (`choice`). We specify the coding (`c(0, 0, 0, 0, 0, 0, 0, 0, 2)`). Remember that in `validateHOT` we specify a linear-coded price in a ACBC as piecewise, which is why we set the last attribute to `2`. For `interpolate.levels`, we specify the lower bound of our price (`Price_2.093`) and the upper bound of price (`Price_27.287`). Finally, we specify `piece.p`, which is equivalent to `lin.p`, however, we specify the position of the lower and the upper bound of the value we would like to interpolate. Since we only have two values if we have a linear-coded price, i.e., the lower and the upper bound, we specify the position of them. Please be aware that you have to specify the position for each alternative in the holdout task, which is why you have to type specify the position `c(35, 36)` for each of the 6 alternatives.

```{r, eval = F}
# define alternatives
prod1 <- c(5, 11, 15, 17, 21, 25, 32, 34, 15.99)
prod2 <- c(6, 9, 15, 17, 23, 27, 31, 34, 12.99)
prod3 <- c(8, 12, 16, 19, 23, 24, 28, 34, 12.99)
prod4 <- c(7, 12, 14, 18, 22, 24, 28, 33, 9.99)
prod5 <- c(4, 10, 13, 17, 23, 27, 28, 34, 7.99)
prod6 <- c(5, 9, 14, 17, 23, 27, 29, 33, 9.99)

# calculate total utilities for validation/ holdout task
HOT <- createHOT(
  data = ACBC,
  id = 1,
  None = 37,
  prod = 6,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  interpolate.levels = list(c(2.093, 27.287)),
  piece.p = list(c(35, 36), c(35, 36), c(35, 36), c(35, 36), c(35, 36), c(35, 36)),
  coding = c(0, 0, 0, 0, 0, 0, 0, 0, 2),
  method = "ACBC",
  choice = 38
)
```

#### Piecewise-coded ACBC

So far, we have only looked at examples where at maximum only one attribute was not part-worth coded. In the final example, we will have all three types of coding included. Since piece-wise coding is only available for ACBC in Sawtooth Software, we will show another example with an ACBC. The data set is similar to the one from the previous example (6 alternatives plus a no-buy alternative). We will use the data frame `ACBC_interpolate`, which is also part of `validateHOT`.

The `coding` specified below (`c(0, 1, 0, 0, 0, 0, 0, 0, 2)`) already tells us that attribute 2 is linear-coded, attribute 9 is piecewise coded, while the rest of the attributes are part-worth coded. For this example, we again specify the six alternatives in the `createHOT` function.

For `interpolate.levels`, we have to specify two vectors. The first vector contains the values for the linear-coded attribute 2 (`c(3, 5, 8, 10)`), and the second vector contains the break points you have specified for your piecewise coded price. In `ACBC_interpolate`, we provide an example where we used 7 break points for the price (`c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)`). We specify the column index of the linear-coded attribute in `lin.p`. Next, we specify `piece.p`. The raw utilities for the 7 break points (`c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)`) are stored in the columns 32 to 38. Again, we need to specify the lower and upper break point of the value we would like to interpolate in `piece.p`, and we need to do this for each of the 6 alternatives. For example, for the first alternative (`15.99`), we see that the lower break point is `12.99` while the upper break point is `17.99`. Therefore, we specify the column index of these two in `piece.p` (`c(36, 37)`). Let us also look at the second product since it represents a scenario you also might face. The alternative should have a price of `12.99`. If we look at the break points we can see that one of the break points is also `12.99`. In this case, we could either use the column index of `12.99` as lower or upper position, the results will be the same.

```{r, eval = F}
HOT <- createHOT(
  data = ACBC_interpolate,
  id = 1,
  None = 39,
  prod = 6,
  prod.levels = list(
    c(5, 5, 12, 14, 18, 22, 29, 31, 15.99),
    c(6, 4, 12, 14, 20, 24, 28, 31, 12.99),
    c(8, 6, 13, 16, 20, 21, 25, 31, 12.99),
    c(7, 5, 11, 15, 19, 21, 25, 30, 9.99),
    c(4, 9, 10, 14, 20, 24, 25, 31, 7.99),
    c(5, 8, 11, 14, 20, 24, 26, 30, 9.99)
  ),
  interpolate.levels = list(c(3, 5, 8, 10), c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)),
  piece.p = list(c(36, 37), c(35, 36), c(35, 36), c(33, 34), c(33, 34), c(33, 34)),
  lin.p = 9,
  coding = c(0, 1, 0, 0, 0, 0, 0, 0, 2),
  method = "ACBC",
  choice = 40
)
```

## Validation metrics

First, we focus on metrics that are often reported for validation/ holdout tasks in research papers, namely:

-   Hit rate (<code>hitrate</code>)
-   Kullback-Leibler-Divergence (<code>kl</code>)
-   Mean absolute error (<code>mae</code>)
-   Mean hit probability (<code>mhp</code>)
-   Median absolute error (<code>medae</code>)
-   Root-mean-squared error (<code>rmse</code>)

### `hitrate`

Once the validation/ holdout task is created using `createHOT()`, the setup is similar for all 3 methods. We will use the MaxDiff example from above. Moreover, since we also would like to show some functions exemplary spitted by group, we will use the `varskeep` argument.

```{r}
HOT <- createHOT(
  data = MaxDiff,
  id = 1,
  None = 19,
  prod = 7,
  prod.levels = list(3, 10, 11, 15, 16, 17, 18),
  method = "MaxDiff",
  choice = 20,
  varskeep = 21
)
```

What we can see from the `createHOT()` function above is that we have 7 alternatives `prod = 7` plus a no-buy alternative since we specified the column index of `None`.

For `hitrate()`, we specify our data (`HOT` in our case), the `id` (unique identifier), the column indexes of alternatives (this includes the no-buy alternative; `opts`), and finally the actual choice in the holdout task (`choice`).

```{r}
hitrate(data = HOT, id = 1, opts = c(2:9), choice = 10)
```

### `kl`

Next, we check the Kullback-Leibler Divergence by running the `kl` function.

```{r}
kl(data = HOT, id = 1, opts = c(2:9), choice = 10)
```
### `mae`

For the mean absolute error, `mae`, we display the results by Group:

```{r}
mae(data = HOT, id = 1, opts = c(2:9), choice = 11, Group = 10)
```

In case, we first had change `Group` to a `factor`, the output would have been adapted accordingly. This is shown in the example in which we use `mae` in `tidyverse` logic. Herefore

```{r, message=F, warning=F}
library(dplyr)
library(magrittr)
HOT %>% 
  dplyr::mutate(Group = factor(Group, levels = c(1:3), labels = paste0("Group ", c(1:3)))) %>%
  mae(., id = 1, opts = c(2:9), Group = 10, choice = 11) %>% 
  dplyr::mutate_if(is.numeric, round, 2)
```

### `mhp`

We will display the mean hit probability again by also specifying the Group

```{r}
mhp(data = HOT, id = 1, opts = c(2:9), choice = 11, Group = 10)
```

### `medae`

Next, we look at the median absolute error.

```{r}
medae(data = HOT, id = 1, opts = c(2:9), choice = 11)
```


### `rmse`

And finally to end this block, we look at the root mean squared error.

```{r}
rmse(data = HOT, id = 1, opts = c(2:9), choice = 11)
```


## Confusion matrix

## Simulation metrics

## References

Orme, B. K., & Chrzan, K. (2017). *Becoming an Expert in Conjoint Analysis. Choice Modelling for Pros*. Orem: Sawtooth Software.

Wickham, H., Hester, J., Chang, W., & Bryan, J. (2022). *devtools: Tools to Make Developing R Packages Easier*. R package version 2.4.5, <https://CRAN.R-project.org/package=devtools>.
