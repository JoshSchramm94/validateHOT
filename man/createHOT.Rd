% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/createHOT.R
\name{createHOT}
\alias{createHOT}
\title{Function to create total utilities for validation task alternatives / market scenario}
\usage{
createHOT(
  data,
  id,
  none = NULL,
  prod.levels,
  coding = NULL,
  interpolate.levels = NULL,
  lin.p = NULL,
  piece.p = NULL,
  method = c("ACBC", "CBC", "MaxDiff"),
  varskeep = NULL,
  choice = NULL
)
}
\arguments{
\item{data}{A data frame with all relevant variables.}

\item{id}{A vector of unique identifier in `data`.}

\item{none}{An optional vector to specify `none`
alternative in `data`.}

\item{prod.levels}{A list to define the attribute levels of the
alternatives (`prod`). If linear-coded or piecewise-coded
attributes are included, column indexes are required for the input.}

\item{coding}{A vector to define attributes coding, `0` = part-worth
coding,`1` = linear coding, `2` = piecewise coding; please make sure to code
linear price of ACBC as piecewise since there are usually two values to interpolate.}

\item{interpolate.levels}{A list of the levels of the attribute that should
be interpolated. These have to be the same as specified in model estimation
(e.g., if you scale or center attribute levels before estimation, insert the same levels).
Please make sure to provide the whole list. Only has to be specified for the
attributes that are coded as `1` (linear) or `2` (piecewise).}

\item{lin.p}{A vector to specify linear coded variables.}

\item{piece.p}{A list of the lower level and the upper
level that should be used for interpolating.}

\item{method}{A character to specify the `method` of your study.
`method` has to be one of the following: `"MaxDiff"`, `"CBC"`, or `"ACBC"`.}

\item{varskeep}{A vector specifying variables that should be kept
in the data frame.}

\item{choice}{Actual choice in the holdout/validation task. Leave empty for
specifying market scenario (warning will be displayed, however).}
}
\value{
a data frame
}
\description{
Function used to create utilities for validation/holdout task or
for the alternatives in a market scenario.
}
\details{
To test the validation metrics of a holdout/validation task or to run a
market scenario, the scenario first has to be created, by summing up
the alternatives part-worth utilities.
This is done with the `createHOT()` function.
Make sure you upload the raw utilities of your study (either from Sawtooth Software
or ChoiceModelR, Sermas, 2022).
The function then creates the alternatives' utility based on the additive
utility model (Rao, 2014, p. 82). If you are working with alternative specific-designs,
insert `NA` if attribute is not specified.

`data` has to be a data frame with raw scores of the attribute
levels.

`id` has to be the column index or column name of the id (unique for each participant)
in data frame.

`none` is required in case a `none` alternative is
included in holdout/validation task, specify
column index or column name of `none` alternative, otherwise leave it empty.


`prod.levels` specifies the attribute levels for each alternative.
Input for `prod.levels` has to be a list. In case
`method = "MaxDiff"`, list should only contain column indexes or
column names of the alternatives in the holdout/validation task or market scenario.
If values for one attribute are interpolated (assuming linear or
piecewise coding), the value to be interpolated has to be specified (numeric
input). In addition, `lin.p` and/or `piece.p`, `interpolate.levels`,
as well as `coding` have to be specified.

`interpolate.levels` is required in case interpolating is used
(only if variables are coded as linear or piecewise).
If scaled or centered values were used for hierarchical Bayes
estimation, the exact same levels are required (all of them).
For example, if one linear coded attribute
had 5 levels, all 5 levels are required. In case for linear coded
price for `method = "ACBC"`, specify both lower bound and upper
bound and code as piecewise in `coding`.
For piecewise-coded price, specify each breakpoint.
Input for `interpolate.levels` has to be a list.

`piece.p` is required in case a variable is coded as
piecewise (see coding). Positions of both lower and upper bound are required.
In case interpolated values (see
`prod.levels`) is equal to a lower or upper bound, this can be specified
either as lower or upper bound. Input for `piece.p` has to be a list.

`lin.p` is required in case a variable is coded as linear
(see coding). Since for linear coding (except for price
in `method = "ACBC"`) only one coefficient is provided in the output,
just this column index or column name is required.

`coding` is required if `method = "CBC"`
or `method = "ACBC"`. Use `0` for part-worth
coding, `1` for linear coding, and `2` for piecewise coding.
In case `method = "ACBC"` and linear price function is used, this
variable has to be coded as piecewise (`2`). In
case `method` is set to `"MaxDiff"`, leave
`coding` empty. Input for `coding` has to be a vector.

`method` specifies the preference measurement method. Can be set to
`"MaxDiff"`, `"CBC"`, or `"ACBC"`.

`varskeep` is required in case other variables should be kept
in the data frame (for example, a grouping variable). Input
for `varskeep` has to be a vector with the column index(es) or names of the
variable(s) that should be kept.

`choice` specifies the column index or column name of the actual choice
in the holdout/validation task. If only a market scenario is specified,
leave `choice` empty, however, a warning will be displayed in this case.
}
\examples{
\dontrun{

library(validateHOT)

# MaxDiff example
HOT_MD <- createHOT(
  data = MaxDiff,
  id = 1,
  none = 19,
  prod.levels = list(3, 10, 11, 15, 16, 17, 18),
  method = "MaxDiff",
  choice = 20
)

# CBC example
HOT_CBC <- createHOT(
  data = CBC,
  id = 1,
  none = 21,
  prod.levels = list(c(4, 9, 19), c(8, 12, 17), c(5, 10, 17)),
  coding = c(0, 0, 0),
  method = "CBC",
  choice = 22
)

# CBC example with linear coding
HOT_CBC_lin <- createHOT(
  data = CBC_lin,
  id = 1,
  none = 15,
  prod.levels = list(c(4, 9, 60), c(8, 12, 40), c(5, 10, 45)),
  coding = c(0, 0, 1),
  interpolate.levels = list(c(10, 20, 30, 40, 50, 60, 70)),
  lin.p = 14,
  method = "CBC",
  varskeep = 17,
  choice = 16
)

# ACBC example with linear price
prod1 <- c(5, 11, 15, 17, 21, 25, 32, 34, 15.99)
prod2 <- c(6, 9, 15, 17, 23, 27, 31, 34, 12.99)
prod3 <- c(8, 12, 16, 19, 23, 24, 28, 34, 12.99)
prod4 <- c(7, 12, 14, 18, 22, 24, 28, 33, 9.99)
prod5 <- c(4, 10, 13, 17, 23, 27, 28, 34, 7.99)
prod6 <- c(5, 9, 14, 17, 23, 27, 29, 33, 9.99)

HOT_ACBC <- createHOT(
  data = ACBC,
  id = 1,
  none = 37,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 0, 0, 0, 0, 0, 0, 0, 2),
  interpolate.levels = list(c(2.093, 27.287)),
  piece.p = list(
    c(35, 36), c(35, 36), c(35, 36),
    c(35, 36), c(35, 36), c(35, 36)
  ),
  method = "ACBC",
  choice = 38
)

prod1 <- c(5, 5, 12, 14, 18, 22, 29, 31, 15.99)
prod2 <- c(6, 4, 12, 14, 20, 24, 28, 31, 12.99)
prod3 <- c(8, 6, 13, 16, 20, 21, 25, 31, 12.99)
prod4 <- c(7, 5, 11, 15, 19, 21, 25, 30, 9.99)
prod5 <- c(4, 9, 10, 14, 20, 24, 25, 31, 7.99)
prod6 <- c(5, 8, 11, 14, 20, 24, 26, 30, 9.99)

HOT_ACBC_inter <- createHOT(
  data = ACBC_interpolate,
  id = 1,
  none = 39,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 1, 0, 0, 0, 0, 0, 0, 2),
  lin.p = 9,
  piece.p = list(
    c(36, 37), c(35, 36), c(35, 36),
    c(33, 34), c(33, 34), c(33, 34)
  ),
  interpolate.levels = list(
    c(3, 5, 8, 10),
    c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)
  ),
  method = "ACBC",
  choice = 40
)
}
}
\references{
{

Rao, V. R. (2014). \emph{Applied Conjoint Analysis}. Heidelberg: Springer
Berlin. \verb{https://doi.org/10.1007/978-3-540-87753-0}

Sermas R (2022). \emph{ChoiceModelR: Choice Modeling in R}. R package version 1.3.0,
\verb{https://CRAN.R-project.org/package=ChoiceModelR}.

}
}
