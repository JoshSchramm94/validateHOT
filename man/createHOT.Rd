% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/createHOT.R
\name{createHOT}
\alias{createHOT}
\title{Function to create total utilities for validation task alternatives / market scenario}
\usage{
createHOT(
  data,
  id,
  none = NULL,
  prod.levels,
  coding = NULL,
  interpolate.levels = NULL,
  lin.p = NULL,
  piece.p = NULL,
  method = c("ACBC", "CBC", "MaxDiff"),
  varskeep = NULL,
  choice = NULL
)
}
\arguments{
\item{data}{A data frame with all relevant variables.}

\item{id}{A vector of unique identifier in \code{data}.}

\item{none}{An optional vector to specify \code{none}
alternative in \code{data}.}

\item{prod.levels}{A list to define the attribute levels of the
alternatives (\code{prod}). If include linear-coded or piecewise-coded
attributes are included, column indexes are needed for the input.}

\item{coding}{A vector of the coding of each attribute, '0' = part-worth
coding,'1' = linear coding, '2' = piecewise coding; please make sure to code
linear price of ACBC as piecewise since you have two values to interpolate.}

\item{interpolate.levels}{A list of the levels of the variables that should
be interpolated. These have to be the same as specified in model estimation
(e.g., if you center attribute levels before estimation, insert the centered levels).
Please make sure to provide the whole list. Only has to be specified for the
variables that are coded as '1' (linear) or '2' (piecewise).}

\item{lin.p}{A vector to specify linear coded variables.}

\item{piece.p}{A list of the lower level and the upper
level that should be used for interpolating.}

\item{method}{A character to specify the \code{method} of your study.
\code{method} has to be one of the following three: "MaxDiff", "CBC", or "ACBC".}

\item{varskeep}{A vector specifying variables that should be kept
in the data frame.}

\item{choice}{Actual choice in the holdout/validation task. Leave empty for
specifying market scenario.}
}
\value{
a data frame
}
\description{
Function used to create utilities for validation task.
}
\details{
In order to test validation metrics of a holdout/validation task, the
holdout/validation task first has to be created.
This is done by the function \code{createHOT}.
Make sure to upload the raw utilities of your study (either from Sawtooth Software
or ChoiceModelR, Sermas, 2022).
Afterwards, the function will create the utilities based on the additive
utility model (Rao, 2014, p. 82). If working with alternative specific-designs,
insert \code{NA} if attribute is not specified.

\code{data} has to be a data frame with raw scores of the attribute
levels.

\code{id} has to be the column index or column name of the id (unique for each participant)
in data frame.

\code{none} has to be specified in case a \code{none} alternative is
included in holdout/validation task, specify
column index or column name of \code{none} alternative, otherwise leave it empty.


\code{prod.levels} specifies the attribute levels for each alternative.
Input for \code{prod.levels} has to be a list. In case
\code{method = "MaxDiff"}, list should only contain column indexes or
column names of the alternatives in the holdout/validation task.
In case values for one attribute are interpolated (assuming linear or
piecewise coding), the value to be interpolated has to be specified (numeric
input). In addition, \code{lin.p} and/or \code{piece.p}, \code{interpolate.levels}
as well as \code{coding} have to be specified.

\code{interpolate.levels} has to be specified in case interpolating is used
(only if variables are coded as linear or piecewise).
If scaled or centered values were used for hierarchical bayes (HB)
estimation, these have to be specified in this case.
All values have to be specified. For example, if one linear coded attribute
had 5 levels, all 5 levels have to be inserted. In case for linear coded
price for \code{method = "ACBC"}, specify both lower bound and upper
bound and code as piecewise in \code{coding}.
For piecewise coded price, specify each breakpoint.
Input for \code{interpolate.levels} has to be a list.

\code{piece.p} has to be specified in case a variable is coded as
piecewise (see coding). Positions of both lower and upper bound have to
be specified. In case interpolated values (see
\code{prod.levels}) is equal to a lower or upper bound, this can be specified
either as lower or upper bound. Input for \code{piece.p} has to be a list.

\code{lin.p} has to be specified in case a variable is coded as linear
(see coding). Since for linear coding (except for price
in \code{method = "ACBC"}) only one coefficient is provided in the output,
just this column index or column name has to be specified.

\code{coding} has to be specified for if \code{method = "CBC"}
or \code{method = "ACBC"}. Use \code{0} for part-worth
coding, \code{1} for linear coding, and \code{2} for piecewise coding.
In case \code{method = "ACBC"} and linear price function is used, this
variable has to be coded as piecewise (\code{2}). In
case \code{method} is set to \code{"MaxDiff"}, leave
\code{coding} empty. Input for \code{coding} has to be a vector.

\code{method} specifies the preference measurement method. Can be set to
\code{"MaxDiff"}, \code{"CBC"}, or \code{"ACBC"}.

\code{varskeep} has to be specified in case other variables should be kept
in the data frame (for example, a grouping variable). Input
for \code{varskeep} has to be a vector with the column index(es) or names of the
variable(s) that should be kept.

\code{choice} specifies the column index or column name of the actual choice
in the holdout/validation task. If only a market scenario is specified,
leave \code{choice} empty.
}
\examples{


\dontrun{

library(validateHOT)

# MaxDiff example
HOT_MD <- createHOT(
  data = MaxDiff,
  id = 1,
  none = 19,
  prod.levels = list(3, 10, 11, 15, 16, 17, 18),
  method = "MaxDiff",
  choice = 20
)

# CBC example
HOT_CBC <- createHOT(
  data = CBC,
  id = 1,
  none = 21,
  prod.levels = list(c(4, 9, 19), c(8, 12, 17), c(5, 10, 17)),
  coding = c(0, 0, 0),
  method = "CBC",
  choice = 22
)

# CBC example with linear coding
HOT_CBC_lin <- createHOT(
  data = CBC_lin,
  id = 1,
  none = 15,
  prod.levels = list(c(4, 9, 60), c(8, 12, 40), c(5, 10, 45)),
  coding = c(0, 0, 1),
  interpolate.levels = list(c(10, 20, 30, 40, 50, 60, 70)),
  lin.p = 14,
  method = "CBC",
  varskeep = 17,
  choice = 16
)

# ACBC example with linear price
prod1 <- c(5, 11, 15, 17, 21, 25, 32, 34, 15.99)
prod2 <- c(6, 9, 15, 17, 23, 27, 31, 34, 12.99)
prod3 <- c(8, 12, 16, 19, 23, 24, 28, 34, 12.99)
prod4 <- c(7, 12, 14, 18, 22, 24, 28, 33, 9.99)
prod5 <- c(4, 10, 13, 17, 23, 27, 28, 34, 7.99)
prod6 <- c(5, 9, 14, 17, 23, 27, 29, 33, 9.99)

HOT_ACBC <- createHOT(
  data = ACBC,
  id = 1,
  none = 37,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 0, 0, 0, 0, 0, 0, 0, 2),
  interpolate.levels = list(c(2.093, 27.287)),
  piece.p = list(
    c(35, 36), c(35, 36), c(35, 36),
    c(35, 36), c(35, 36), c(35, 36)
  ),
  method = "ACBC",
  choice = 38
)

prod1 <- c(5, 5, 12, 14, 18, 22, 29, 31, 15.99)
prod2 <- c(6, 4, 12, 14, 20, 24, 28, 31, 12.99)
prod3 <- c(8, 6, 13, 16, 20, 21, 25, 31, 12.99)
prod4 <- c(7, 5, 11, 15, 19, 21, 25, 30, 9.99)
prod5 <- c(4, 9, 10, 14, 20, 24, 25, 31, 7.99)
prod6 <- c(5, 8, 11, 14, 20, 24, 26, 30, 9.99)

HOT_ACBC_inter <- createHOT(
  data = ACBC_interpolate,
  id = 1,
  none = 39,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 1, 0, 0, 0, 0, 0, 0, 2),
  lin.p = 9,
  piece.p = list(
    c(36, 37), c(35, 36), c(35, 36),
    c(33, 34), c(33, 34), c(33, 34)
  ),
  interpolate.levels = list(
    c(3, 5, 8, 10),
    c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)
  ),
  method = "ACBC",
  choice = 40
)
}
}
\references{
{

Rao, V. R. (2014). \emph{Applied Conjoint Analysis}. Heidelberg: Springer
Berlin. \verb{https://doi.org/10.1007/978-3-540-87753-0}

Sermas R (2022). \emph{ChoiceModelR: Choice Modeling in R}. R package version 1.3.0,
\verb{https://CRAN.R-project.org/package=ChoiceModelR}.

}
}
