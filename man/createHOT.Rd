% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/createHOT.R
\name{createHOT}
\alias{createHOT}
\title{Preparing holdout/validation task and creating utilities}
\usage{
createHOT(
  data,
  id,
  None = NULL,
  prod,
  prod.levels,
  interpolate.levels = NULL,
  piece.p = NULL,
  lin.p = NULL,
  coding = NULL,
  method = c("ACBC" | "CBC" | "MaxDiff"),
  varskeep = NULL,
  choice
)
}
\arguments{
\item{data}{data frame with all relevant variables.}

\item{id}{vector of column index of unique identifier in \code{data}.}

\item{None}{optional column index to specify \code{None} alternative in \code{data}.}

\item{prod}{number of alternatives in the holdout/validation task (does not count the \code{None} alternative); input has to be numeric}

\item{prod.levels}{a list to define the attribute levels of the alternatives (\code{prod})}

\item{interpolate.levels}{a list of the levels of the variables that should be interpolated. These have to be the same as provided to Sawtooth Software. Please make sure to provide the whole list. Only needs to be specified for the variables that are coded as '1' (linear) or '2' (piecewise)}

\item{piece.p}{a list of the column indexes of the lower level and the upper level that should be used for interpolating}

\item{lin.p}{vector of the column indexes of the linear variables}

\item{coding}{vector of the coding of each attribute, '0' = part-worth coding, '1' = linear coding, '2' = piecewise coding; please make sure to code linear price of ACBC as piecewise since you have two values to interpolate}

\item{method}{specify the \code{method} your study; has to be one of the following three: MaxDiff, CBC, or ACBC}

\item{varskeep}{vector of column index(es) of variables that should be kept in the data frame}

\item{choice}{actual choice in the holdout/validation task}
}
\value{
a data frame
}
\description{
Function used to create utilities for validation task.
}
\details{
In order to test validation metrics of a holdout/validation task, the holdout/validation task first has to be created.
This is done by the function \code{createHOT}.
Make sure to upload the raw utilities of your study.
Afterwards, the function will create the utilities based on the additive utility model (Rao, 2014, p. 82).

\code{data} has to be a data frame with **raw** scores of the attribute levels.

\code{id} has to be the column index of the id (unique for each participant) in data frame.

\code{None} has to be specified in case a \code{None} alternative is included in
holdout/validation task, please specify this by specifying the column index of \code{None} alternative, otherwise leave it empty.

\code{prod} should specify the total number of alternatives included in your holdout/validation task (excluding the \code{None} alternative).

\code{prod.levels} specifies the attribute levels for each alternative. Input for \code{prod.levels} has to be a list. In case \code{method = "MaxDiff"}
this will only be a list of the column indexes of the alternatives in the holdout/validation task. If \code{method = "CBC"} or
\code{method = "ACBC"} use a vector to specify the attribute levels for each alternative. For \code{method = "CBC"} and \code{method = "ACBC"}
also the column index(es) of the attribute level has to be specified.
In case values for one attribute are interpolated (assuming linear or
piecewise coding), the value to be interpolated needs to be specified.
In addition, \code{lin.p} and/or \code{piece.p}, \code{interpolate.levels}
as well as \code{coding} have to be specified.

\code{interpolate.levels} has to be specified in case interpolating is used (only if variables are coded as linear or piecewise).
If scaled or centered values were used for hierarchical bayes (HB) estimation, these have to be specified in this case.
All values have to be specified. For example if one linear coded attribute had 5 levels, all 5 levels have to be inserted.
In case for linear coded price for \code{method = "ACBC"}, specify both lower bound and upper bound and code as piecewise in \code{coding}.
For piecewise coded price, specify each breakpoint. Input for \code{interpolate.levels} has to be a list.

\code{piece.p} has to be specified in case a variable is coded as piecewise (see coding).
Positions of both lower and upper bound have to be specified. In case interpolated values (see
prod.levels) is equal to a lower or upper bound, this can be specified either as
lower or upper bound. Input for \code{piece.p} has to be a list.

\code{lin.p} has to be specified in case a variable is coded as linear (see coding).
Since for linear coding (except for price in \code{method = "ACBC"}) only one
coefficient is provided in the output, just this column index has to be specified, consequently, input for \code{piece.p} has to be a vector.

\code{coding} has to be specified for if \code{method = "CBC"} or \code{method = "ACBC"}.
\code{0} has to be used for parth-worth coding, \code{1} for linear coding, and \code{2} for piecewise coding.
In case \code{method = "ACBC"} and linear price function is used, this variable has to be coded
as piecewise (\code{2}) in this case. In case \code{method} is set to \code{"MaxDiff"}, leave
\code{coding} empty. Input for \code{coding} has to be a vector.

\code{method} specifies the preference measurement method. Can be set to
\code{"MaxDiff"}, \code{"CBC"}, or \code{"ACBC"}.

\code{varskeep} has to be specified in case other variables should be kept in the
data frame (for example, a grouping variable). Input for \code{varskeep} has to be a vector
with the column index(es) of the variable(s) that should be kept.

\code{choice} specifies the column index of the acutal choice in the holdout/validation task.
}
\examples{
\dontrun{
# MaxDiff example
createHOT(
  data = MaxDiff,
  id = 1,
  None = 19,
  prod = 7,
  prod.levels = list(3, 10, 11, 15, 16, 17, 18),
  method = "MaxDiff",
  choice = 20
)

# CBC example
createHOT(
  data = CBC,
  id = 1,
  None = 21,
  prod = 3,
  prod.levels = list(c(4, 9, 19), c(8, 12, 17), c(5, 10, 17)),
  coding = c(0, 0, 0),
  method = "CBC",
  choice = 22
)

# CBC example with linear coding
createHOT(
  data = CBC_lin,
  id = 1,
  None = 15,
  prod = 3,
  prod.levels = list(c(4, 9, 60), c(8, 12, 40), c(5, 10, 45)),
  interpolate.levels = list(c(10, 20, 30, 40, 50, 60, 70)),
  lin.p = 14,
  coding = c(0, 0, 1),
  method = "CBC",
  varskeep = 17,
  choice = 16
)

# ACBC example with linear price
prod1 <- c(5, 11, 15, 17, 21, 25, 32, 34, 15.99)
prod2 <- c(6, 9, 15, 17, 23, 27, 31, 34, 12.99)
prod3 <- c(8, 12, 16, 19, 23, 24, 28, 34, 12.99)
prod4 <- c(7, 12, 14, 18, 22, 24, 28, 33, 9.99)
prod5 <- c(4, 10, 13, 17, 23, 27, 28, 34, 7.99)
prod6 <- c(5, 9, 14, 17, 23, 27, 29, 33, 9.99)

createHOT(
  data = ACBC,
  id = 1,
  None = 37,
  prod = 6,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  interpolate.levels = list(c(2.093, 27.287)),
  piece.p = list(c(35, 36), c(35, 36), c(35, 36), c(35, 36), c(35, 36), c(35, 36)),
  coding = c(0, 0, 0, 0, 0, 0, 0, 0, 2),
  method = "ACBC",
  choice = 38
)

prod1 <- c(5, 5, 12, 14, 18, 22, 29, 31, 15.99)
prod2 <- c(6, 4, 12, 14, 20, 24, 28, 31, 12.99)
prod3 <- c(8, 6, 13, 16, 20, 21, 25, 31, 12.99)
prod4 <- c(7, 5, 11, 15, 19, 21, 25, 30, 9.99)
prod5 <- c(4, 9, 10, 14, 20, 24, 25, 31, 7.99)
prod6 <- c(5, 8, 11, 14, 20, 24, 26, 30, 9.99)

createHOT(
  data = ACBC_interpolate,
  id = 1,
  None = 39,
  prod = 6,
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  interpolate.levels = list(c(3, 5, 8, 10), c(1.99, 6.99, 9.99, 10.99, 12.99, 17.99, 25.99)),
  piece.p = list(c(36, 37), c(35, 36), c(35, 36), c(33, 34), c(33, 34), c(33, 34)),
  lin.p = 9,
  coding = c(0, 1, 0, 0, 0, 0, 0, 0, 2),
  method = "ACBC",
  choice = 40
)
}
}
\references{
{

Rao, V. R. (2014). \emph{Applied Conjoint Analysis}. Heidelberg: Springer Berlin. \verb{https://doi.org/10.1007/978-3-540-87753-0}

}
}
