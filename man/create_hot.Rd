% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_hot.R
\name{create_hot}
\alias{create_hot}
\title{Function to calculate total utilities for validation task
alternatives or market scenario}
\usage{
create_hot(
  data,
  id,
  none = NULL,
  prod.levels,
  coding = NULL,
  interpolate.levels = NULL,
  lin.p = NULL,
  piece.p = NULL,
  method = c("acbc", "cbc", "maxdiff"),
  varskeep = NULL,
  choice = NULL
)
}
\arguments{
\item{data}{A data frame containing all relevant variables.}

\item{id}{Column name of the unique identifier.}

\item{none}{An optional vector to specify column name of the \code{none}
alternative.}

\item{prod.levels}{A list to define the attribute levels of the
alternatives (\code{prod}). If linear-coded or piecewise-coded
attributes are included, column indexes are required for the input.}

\item{coding}{A vector to define attributes coding, \code{0} = part-worth
coding, \code{1} = linear coding, \code{2} = piecewise coding; please make sure to code
linear price of ACBC as piecewise. For more details, see the example
provided below. If you want to treat a part-worth coded variable
continuously, use the code \code{2} for this variable and provide the values in
\code{interpolate.levels} accordingly.}

\item{interpolate.levels}{A list of the levels of the attribute that should
be interpolated. These levels must match those specified in model
estimation (e.g., if you scale or center attribute levels before estimation,
insert the scaled or centered levels). Ensure to provide the
entire list. It has to be specified only for the attributes that are coded
as \code{1} (linear) or \code{2} (piecewise).}

\item{lin.p}{A vector to specify column index or column names of
linear-coded variables.}

\item{piece.p}{A nested list containing lists each of the piecewise-coded
variables. The list for a piecewise-coded attribute must specify the columns
representing the lower and upper levels to be used for interpolation.}

\item{method}{A character string to specify the \code{method} of your study.
\code{method} has to be one of the following: \code{"maxdiff"}, \code{"cbc"}, or \code{"acbc"}.}

\item{varskeep}{A vector specifying column names of the variables that should
be kept in the data frame.}

\item{choice}{Actual choice in the validation task. Leave \code{choice} empty for
specifying market scenario (a warning will be displayed).}
}
\description{
Function to calculate total utilities for validation task
alternatives or market scenario
}
\details{
To test the validation metrics of a validation task or to run a market
scenario, the scenario first has to be created by summing up the raw
utilities of the alternatives. This is achieved using the \code{create_hot()}
function.  Make sure that you upload the raw utilities of your study (either
from Sawtooth Software Lighthouse Studio or ChoiceModelR, Sermas, 2022).
The function then calculates the alternatives' utilities based on the
additive utility model (Rao, 2014, p. 82). For alternative-specific designs,
insert \code{NA} for attributes not specified.

\code{data} must be a \code{data.frame} object with raw scores of the attribute
levels.

\code{id} has to be the column index or column name of the id (unique for each
participant) in the data frame.

\code{none} to specify name of the \code{none} alternative if it is included
in the validation task. Leave \code{none} empty, if no \code{none} alternative is
included.

\code{prod.levels} specifies the attribute levels for each alternative.
Input for \code{prod.levels} has to be a list. For attributes requiring
interpolation (linear or piecewise coding), specify the values to
interpolate (numeric input). In addition, \code{lin.p} and/or \code{piece.p},
\code{interpolate.levels}, and \code{coding} have to be
specified.

\code{interpolate.levels} is required in case interpolation is used (only if
variables are coded as linear or piecewise or if you want to treat a
part-worth coded variable as continuous). If scaled or centered values
were used for hierarchical Bayes estimation, the exact same levels are
required (all of them). For example, if one linear-coded attribute
had 5 levels, all 5 levels are required. In the case of linear-coded price
for \code{method = "acbc"} (and you have two price coefficients which sum up to
\code{0}), specify both lower and upper bound and code as
piecewise in \code{coding}. For piecewise-coded price, specify each breakpoint.
Input for \code{interpolate.levels} has to be a list.

\code{piece.p} is required in case a variable is coded as piecewise (see coding).
Positions of both lower and upper bound are required. In case interpolated
values (see \code{prod.levels}) are equal to a lower or upper bound, this can be
specified either as lower or upper bound. Input for  \code{piece.p} has to be a
nested list and must contain a list for each piecewise-coded attribute.

\code{lin.p} is required in case a variable is linear-coded
(see coding). Since for linear coding (except for price
in \code{method = "acbc"}) only one coefficient is provided in the output,
provide this column name accordingly.

\code{coding} is required if \code{method = "cbc"} or \code{method = "acbc"}. Use \code{0} for
part-worth coding, \code{1} for linear coding, and \code{2} for piecewise coding.
In case \code{method = "acbc"} and linear price function is used, this variable
has to be coded as piecewise (\code{2}). In case \code{method} is set to \code{"maxdiff"}
leave \code{coding} empty. If a part-worth coded variable should be treated as
continuous, set it to \code{2}. Input for \code{coding} has to be a vector.

\code{method} specifies the preference measurement method. Can be set to
\code{"maxdiff"}, \code{"cbc"}, or \code{"acbc"}.

\code{varskeep} is required in case other variables should be kept
in the data frame (for example, a grouping variable). Provide the column
names of the variable(s) that should be kept.

\code{choice} specifies the column name of the actual choice
in the validation task.

Instead of the column names, one can also provide column indexes.
}
\examples{
\dontrun{

# MaxDiff example
hot_mxd <- create_hot(
  data = maxdiff,
  id = "id",
  none = "none",
  prod.levels = list(2, 9, 10, 14, 15, 16, 17),
  method = "maxdiff",
  varskeep = "group",
  choice = "hot"
)

# CBC example
hot_cbc <- create_hot(
  data = cbc,
  id = "id",
  none = "none",
  prod.levels = list(
    c(3, 6, 10, 13, 16, 20, 24, 32, 35),
    c(3, 5, 10, 14, 16, 18, 22, 27, 35),
    c(4, 6, 9, 14, 15, 20, 25, 30, 36),
    c(4, 5, 10, 11, 16, 19, 26, 32, 34),
    c(2, 6, 8, 14, 16, 17, 26, 31, 36),
    c(2, 5, 7, 12, 16, 20, 26, 29, 33)
  ),
  coding = c(rep(0, times = 9)),
  method = "cbc",
  choice = "hot"
)

# CBC example with linear coding
hot_cbc_linear <- create_hot(
  data = cbc_linear,
  id = "id",
  none = "none",
  prod.levels = list(
    c(3, 6, 10, 13, 16, 20, 24, 32, 248.55),
    c(3, 5, 10, 14, 16, 18, 22, 27, 237.39),
    c(4, 6, 9, 14, 15, 20, 25, 30, 273.15),
    c(4, 5, 10, 11, 16, 19, 26, 32, 213.55),
    c(2, 6, 8, 14, 16, 17, 26, 31, 266.10),
    c(2, 5, 7, 12, 16, 20, 26, 29, 184.50)
  ),
  coding = c(rep(0, times = 8), 1),
  lin.p = 33,
  interpolate.levels = list(c(seq(from = 175.99, to = 350.99, by = 35))),
  method = "cbc",
  choice = "hot"
)

# ACBC example with linear price
prod1 <- c(3, 6, 10, 13, 16, 20, 24, 32, 248.55)
prod2 <- c(3, 5, 10, 14, 16, 18, 22, 27, 237.39)
prod3 <- c(4, 6, 9, 14, 15, 20, 25, 30, 273.15)
prod4 <- c(4, 5, 10, 11, 16, 19, 26, 32, 213.55)
prod5 <- c(2, 6, 8, 14, 16, 17, 26, 31, 266.10)
prod6 <- c(2, 5, 7, 12, 16, 20, 26, 29, 184.50)

hot_acbc <- create_hot(
  data = acbc,
  id = "id",
  none = "none",
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(rep(0, times = 8), 2),
  interpolate.levels = list(c(121.95, 507.95)),
  piece.p = list(
    list(
      c(33, 34), c(33, 34), c(33, 34),
      c(33, 34), c(33, 34), c(33, 34)
    )
  ),
  method = "acbc",
  choice = "hot"
)

prod1 <- c(3, 10, 9, 12, 15, 19, 23, 31, 248.55)
prod2 <- c(3, 9, 9, 13, 15, 17, 21, 26, 237.39)
prod3 <- c(4, 10, 8, 13, 14, 19, 24, 29, 273.15)
prod4 <- c(4, 9, 9, 10, 15, 18, 25, 31, 213.55)
prod5 <- c(2, 10, 7, 13, 15, 16, 25, 30, 266.10)
prod6 <- c(2, 9, 6, 11, 15, 19, 25, 28, 184.50)

hot_acbc_interpolate <- create_hot(
  data = acbc_interpolate,
  id = "id",
  none = "none",
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 1, rep(0, times = 6), 2),
  lin.p = 5,
  interpolate.levels = list(
    c(9, 10),
    c(121.95, 226.95, 272.95, 326.95, 507.95)
  ),
  piece.p = list(
    list(
      c(33, 34), c(33, 34), c(34, 35),
      c(32, 33), c(33, 34), c(32, 33)
    )
  ),
  method = "acbc",
  choice = "hot"
)
}
}
\references{
{

Rao, V. R. (2014). \emph{Applied Conjoint Analysis}. Heidelberg: Springer
Berlin. \verb{https://doi.org/10.1007/978-3-540-87753-0}

Sermas R (2022). \emph{ChoiceModelR: Choice Modeling in R}. R package
version 1.3.0, \verb{https://CRAN.R-project.org/package=ChoiceModelR}.

}
}
