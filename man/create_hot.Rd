% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_hot.R
\name{create_hot}
\alias{create_hot}
\title{Function to create total utilities for validation task alternatives
or market scenario}
\usage{
create_hot(
  data,
  id,
  none = NULL,
  prod.levels,
  coding = NULL,
  interpolate.levels = NULL,
  lin.p = NULL,
  piece.p = NULL,
  method = c("acbc", "cbc", "maxdiff"),
  varskeep = NULL,
  choice = NULL
)
}
\arguments{
\item{data}{A data frame with all relevant variables.}

\item{id}{A vector of unique identifier in \code{data}.}

\item{none}{An optional vector to specify \code{none}
alternative in \code{data}.}

\item{prod.levels}{A list to define the attribute levels of the
alternatives (\code{prod}). If linear-coded or piecewise-coded
attributes are included, column indexes are required for the input.}

\item{coding}{A vector to define attributes coding, \code{0} = part-worth
coding,\code{1} = linear coding, \code{2} = piecewise coding; please make sure to code
linear price of ACBC as piecewise. For more details, see the example
provided below.}

\item{interpolate.levels}{A list of the levels of the attribute that should
be interpolated. These have to be the same as specified in model estimation
(e.g., if you scale or center attribute levels before estimation, insert the
scaled or centered levels). Please make sure to provide the whole list.
Only has to be specified for the attributes that are coded as \code{1} (linear)
or \code{2} (piecewise).}

\item{lin.p}{A vector to specify column index or column names of
linear coded variables.}

\item{piece.p}{A nested list, with a list for each of the piecewise-coded
variables. List for a piecewise-cded attribute must be the columns that
shoud be the lower and the upper level that should be used for interpolating.}

\item{method}{A character to specify the \code{method} of your study.
\code{method} has to be one of the following: \code{"maxdiff"}, \code{"cbc"}, or \code{"acbc"}.}

\item{varskeep}{A vector specifying variables that should be kept
in the data frame.}

\item{choice}{Actual choice in the validation task. Leave empty for
specifying market scenario (warning will be displayed, however).}
}
\description{
Function to create total utilities for validation task alternatives
or market scenario
}
\details{
To test the validation metrics of a validation task or to run a
market scenario, the scenario first has to be created by summing up
the alternatives part-worth utilities. This is done with the \code{create_hot()}
function.  Make sure you upload the raw utilities of your study (either
from Sawtooth Software or ChoiceModelR, Sermas, 2022).
The function then creates the alternatives' utility based on the additive
utility model (Rao, 2014, p. 82). If you are working with alternative
specific-designs, insert \code{NA} if attribute is not specified.

\code{data} has to be a data frame with raw scores of the attribute
levels.

\code{id} has to be the column index or column name of the id (unique for each
participant) in data frame.

\code{none} to specify a \code{none} alternative if it is included in validation task.
Specify column index or column name of \code{none} alternative. If there was no
\code{none} alternative in the validation task, leave it empty.

\code{prod.levels} specifies the attribute levels for each alternative.
Input for \code{prod.levels} has to be a list. If values for one attribute are
supposed to be interpolated (assuming linear or piecewise coding), the
value to be interpolated has to be specified (numeric input). In addition,
\code{lin.p} and/or \code{piece.p}, \code{interpolate.levels}, and \code{coding} have to be
specified.

\code{interpolate.levels} is required in case interpolating is used (only if
variables are coded as linear or piecewise). If scaled or centered values
were used for hierarchical Bayes estimation, the exact same levels are
required (all of them). For example, if one linear coded attribute
had 5 levels, all 5 levels are required. In case for linear coded price for
\code{method = "acbc"}, specify both lower bound and upper bound and code as
piecewise in \code{coding}. For piecewise-coded price, specify each breakpoint.
Input for \code{interpolate.levels} has to be a list.

\code{piece.p} is required in case a variable is coded as piecewise (see coding).
Positions of both lower and upper bound are required. In case interpolated
values (see \code{prod.levels}) is equal to a lower or upper bound, this can be
specified either as lower or upper bound. Input for  \code{piece.p} has to be a
nested list and must contain a list for each piecewise-coded attribute.

\code{lin.p} is required in case a variable is coded as linear
(see coding). Since for linear coding (except for price
in \code{method = "acbc"}) only one coefficient is provided in the output,
just this column index or column name is required.

\code{coding} is required if \code{method = "cbc"} or \code{method = "acbc"}. Use \code{0} for
part-worth coding, \code{1} for linear coding, and \code{2} for piecewise coding.
In case \code{method = "acbc"} and linear price function is used, this variable
has to be coded as piecewise (\code{2}). In case \code{method} is set to \code{"maxdiff"}
\code{coding} empty. Input for \code{coding} has to be a vector.

\code{method} specifies the preference measurement method. Can be set to
\code{"maxdiff"}, \code{"cbc"}, or \code{"acbc"}.

\code{varskeep} is required in case other variables should be kept
in the data frame (for example, a grouping variable). Input
for \code{varskeep} has to be a vector with the column index(es) or names of the
variable(s) that should be kept.

\code{choice} specifies the column index or column name of the actual choice
in the validation task. If only a market scenario is specified, leave
\code{choice} empty, however, a warning will be displayed in this case.
}
\examples{
\dontrun{

# MaxDiff example
hot_mxd <- create_hot(
  data = maxdiff,
  id = "id",
  none = "none",
  prod.levels = list(2, 9, 10, 14, 15, 16, 17),
  method = "maxdiff",
  varskeep = "group",
  choice = "hot"
)

# CBC example
hot_cbc <- create_hot(
  data = cbc,
  id = "id",
  none = "none",
  prod.levels = list(
    c(3, 6, 10, 13, 16, 20, 24, 32, 35),
    c(3, 5, 10, 14, 16, 18, 22, 27, 35),
    c(4, 6, 9, 14, 15, 20, 25, 30, 36),
    c(4, 5, 10, 11, 16, 19, 26, 32, 34),
    c(2, 6, 8, 14, 16, 17, 26, 31, 36),
    c(2, 5, 7, 12, 16, 20, 26, 29, 33)
  ),
  coding = c(rep(0, times = 9)),
  method = "cbc",
  choice = "hot"
)

# CBC example with linear coding
hot_cbc_linear <- create_hot(
  data = cbc_linear,
  id = "id",
  none = "none",
  prod.levels = list(
    c(3, 6, 10, 13, 16, 20, 24, 32, 248.55),
    c(3, 5, 10, 14, 16, 18, 22, 27, 237.39),
    c(4, 6, 9, 14, 15, 20, 25, 30, 273.15),
    c(4, 5, 10, 11, 16, 19, 26, 32, 213.55),
    c(2, 6, 8, 14, 16, 17, 26, 31, 266.10),
    c(2, 5, 7, 12, 16, 20, 26, 29, 184.50)
  ),
  coding = c(rep(0, times = 8), 1),
  lin.p = 33,
  interpolate.levels = list(c(seq(from = 175.99, to = 350.99, by = 35))),
  method = "cbc",
  choice = "hot"
)

# ACBC example with linear price
prod1 <- c(3, 6, 10, 13, 16, 20, 24, 32, 248.55)
prod2 <- c(3, 5, 10, 14, 16, 18, 22, 27, 237.39)
prod3 <- c(4, 6, 9, 14, 15, 20, 25, 30, 273.15)
prod4 <- c(4, 5, 10, 11, 16, 19, 26, 32, 213.55)
prod5 <- c(2, 6, 8, 14, 16, 17, 26, 31, 266.10)
prod6 <- c(2, 5, 7, 12, 16, 20, 26, 29, 184.50)

hot_acbc <- create_hot(
  data = acbc,
  id = "id",
  none = "none",
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(rep(0, times = 8), 2),
  interpolate.levels = list(c(121.95, 507.95)),
  piece.p = list(
    list(
    c(33, 34), c(33, 34), c(33, 34),
    c(33, 34), c(33, 34), c(33, 34)
    )
  ),
  method = "acbc",
  choice = "hot"
)

prod1 <- c(3, 10, 9, 12, 15, 19, 23, 31, 248.55)
prod2 <- c(3, 9, 9, 13, 15, 17, 21, 26, 237.39)
prod3 <- c(4, 10, 8, 13, 14, 19, 24, 29, 273.15)
prod4 <- c(4, 9, 9, 10, 15, 18, 25, 31, 213.55)
prod5 <- c(2, 10, 7, 13, 15, 16, 25, 30, 266.10)
prod6 <- c(2, 9, 6, 11, 15, 19, 25, 28, 184.50)

hot_acbc_interpolate <- create_hot(
  data = acbc_interpolate,
  id = "id",
  none = "none",
  prod.levels = list(prod1, prod2, prod3, prod4, prod5, prod6),
  coding = c(0, 1, rep(0, times = 6), 2),
  lin.p = 5,
  interpolate.levels = list(
    c(9, 10),
    c(121.95, 226.95, 272.95, 326.95, 507.95)
  ),
  piece.p = list(
    list(
    c(33, 34), c(33, 34), c(34, 35),
    c(32, 33), c(33, 34), c(32, 33)
    )
  ),
  method = "acbc",
  choice = "hot"
)
}
}
\references{
{

Rao, V. R. (2014). \emph{Applied Conjoint Analysis}. Heidelberg: Springer
Berlin. \verb{https://doi.org/10.1007/978-3-540-87753-0}

Sermas R (2022). \emph{ChoiceModelR: Choice Modeling in R}. R package
version 1.3.0, \verb{https://CRAN.R-project.org/package=ChoiceModelR}.

}
}
